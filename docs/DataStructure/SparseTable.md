## きもち

演算£に対して £(l, r) = l £ l+1 £ l+2 £ ... £ r-1 を高速に求めたい。  
セグメント木では£が結合則を満たすとき、予めl,rに応じて定まる値mをとり、£(l, m)と£(m, r)を前計算しておくことでクエリを高速化した。  
このとき£が冪等性を持つならば同じmでなくとも l <= mr <= ml <= r なるml , mrをとり£(l, ml)と£(mr, r)を計算しておけばよい。  
言い換えると、前計算の始点を固定したとき、前計算する長さは終点とは独立して決めて良い。  
前計算の長さは2の冪乗ずつにすると、ダブリングを利用して求めることができ、かつ上手いことどのような範囲にも対応できる。  
セグメント木と比較するとクエリが高速だが、配列の値を更新するクエリには対応できない。  

## 使い方

- `SparseTable(vector<T> v, T e, function<T(T, T)> operation)`：配列v, 演算の単位元e, 演算operationのスパーステーブルを構築する。  
- `T query(long l, long r)`：半開区間\[l, r)に対して l £ l+1 £ ... £ r-1 を求める。  

## 計算量

構築:$\mathrm{O}(NlogN)$  
クエリ:$\mathrm{O}(1)$  

## Tips

このような演算£とその集合がなす代数構造は冪等半群とよばれるらしいです。
